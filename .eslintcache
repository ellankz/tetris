[{"G:\\Учеба\\study\\frontend\\tetris\\src\\index.js":"1","G:\\Учеба\\study\\frontend\\tetris\\src\\reportWebVitals.js":"2","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Game\\Game.js":"3","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Field\\Field.js":"4","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Space\\Space.js":"5","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Brick\\Brick.js":"6","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\BlockFactory\\BlockFactory.js":"7","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Tile\\Tile.js":"8","G:\\Учеба\\study\\frontend\\tetris\\src\\helpers\\index.js":"9"},{"size":508,"mtime":1613481234009,"results":"10","hashOfConfig":"11"},{"size":362,"mtime":499162500000,"results":"12","hashOfConfig":"11"},{"size":8085,"mtime":1613566077008,"results":"13","hashOfConfig":"11"},{"size":511,"mtime":1613481233974,"results":"14","hashOfConfig":"11"},{"size":122,"mtime":1613481234005,"results":"15","hashOfConfig":"11"},{"size":115,"mtime":1613481233972,"results":"16","hashOfConfig":"11"},{"size":597,"mtime":1613481233970,"results":"17","hashOfConfig":"11"},{"size":162,"mtime":1613481234007,"results":"18","hashOfConfig":"11"},{"size":63,"mtime":1613481234008,"results":"19","hashOfConfig":"11"},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"r83r6s",{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"27"},{"filePath":"28","messages":"29","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"30","messages":"31","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},{"filePath":"38","messages":"39","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"22"},"G:\\Учеба\\study\\frontend\\tetris\\src\\index.js",[],["40","41"],"G:\\Учеба\\study\\frontend\\tetris\\src\\reportWebVitals.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Game\\Game.js",["42"],"import { useState, useEffect, useRef } from 'react';\nimport Field from '../Field/Field';\nimport { cloneMatrix } from '../../helpers';\n\nconst FIELD_CENTER_X = 4;\nconst RIGHT_WALL_X = 11;\nconst BOTTOM_WALL_Y = 20;\n\n\n\nfunction Game() {\n  const initialFieldState = [\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','0','0','0','0','0','0','0','0','0','0','#'],\n    ['#','#','#','#','#','#','#','#','#','#','#','#'],\n  ];\n\n  const [fieldState, setFieldState] = useState(cloneMatrix(initialFieldState));\n\n  const [fieldWithShape, setFieldWithShape] = useState(cloneMatrix(initialFieldState));\n\n  const [fallingShape, setFallingShape] = useState(() => createRandomShape(getRandomColor()));\n\n  const [shapePosition, setShapePosition] = useState({x: FIELD_CENTER_X, y: 0});\n\n  const [direction, setDirection] = useState(null);\n\n  function getRandomColor() {\n    const colors = ['r', 'g', 'b', 'p', 'c', 'y'];\n    const randNum = Math.floor(Math.random() * colors.length);\n    const randColor = colors[randNum];\n\n    return randColor;\n  }\n\n  function createRandomShape(colorLetter) {\n    const shapes = [\n      [\n        ['1', '1'],\n        ['1', '1'],\n      ],\n      [\n        ['0', '1', '0'],\n        ['1', '1', '1'],\n      ],\n      [\n        ['1', '1', '1', '1', '1'],\n      ],\n      [\n        ['1', '0'],\n        ['1', '0'],\n        ['1', '1'],\n      ],\n      [\n        ['0', '1'],\n        ['0', '1'],\n        ['1', '1'],\n      ],\n      [\n        ['1', '0'],\n        ['1', '1'],\n        ['0', '1'],\n      ],\n      [\n        ['0', '1'],\n        ['1', '1'],\n        ['1', '0']\n      ]\n    ];\n    const randNum = Math.floor(Math.random() * shapes.length);\n    const newShape = shapes[randNum].map((row) => row.map((tile) => tile === '1' ? colorLetter : tile));\n    return newShape;\n  }\n\n  let keyPressTime = useRef();\n  keyPressTime.current = new Date().getTime();\n\n  useEffect(() => {\n    function updateField (newPos, rotated) {\n      if ((!newPos && !rotated)\n      || (!rotated && newPos.x === shapePosition.x && newPos.y === shapePosition.y)) return;\n      let field = cloneMatrix(fieldWithShape);\n  \n      function clearShape() {\n        field = cloneMatrix(fieldState);\n      }\n  \n      function drawShape() {\n        const shape = rotated || fallingShape;\n        const pos = newPos || shapePosition;\n        for (let i = 0; i < shape.length; i++) {\n          for (let u = 0; u < shape[0].length; u++) {\n            if (shape[i][u] !== '0') {\n              field[pos.y + i][pos.x + u] = shape[i][u];\n            }\n          }\n        }\n      }\n\n      clearShape();\n      drawShape();\n      setFieldWithShape(field);\n    };\n\n    function detectCollision(newPos, rotated) {\n      if (!newPos && !rotated) return false;\n      const {x, y} = newPos || shapePosition;\n      const shape = rotated || fallingShape;\n      if (x < 1 || x + shape[0].length > RIGHT_WALL_X || y >=  BOTTOM_WALL_Y) {\n        return true;\n      }\n      function mapShapeToLayedTiles() {\n        for (let i = y; i < y + shape.length; i++) {\n          for (let u = x; u < x + shape[0].length; u++) {\n            if (shape[i - y][u - x] !== '0') {\n              if (fieldState[i][u] !== '0') {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      }\n  \n      return mapShapeToLayedTiles();\n    };\n    \n    function moveShape(direction) {\n      let newPos;\n      const savedPos = { ...shapePosition };\n      switch (direction) {\n        case 'left':\n          newPos = { ...savedPos, x: savedPos.x - 1};\n          break;\n        case 'right':\n          newPos = { ...savedPos, x: savedPos.x + 1};\n          break;\n        case 'down':\n          newPos = { x: savedPos.x, y: savedPos.y + 1};\n          break;\n        default:\n          break;\n        }\n        if (newPos) setShapePosition(newPos);\n\n      const collided = detectCollision(newPos);\n\n      if (collided) {\n        setShapePosition(savedPos);\n      }\n\n      return newPos;\n    }\n\n    function rotateShape() {\n      const shape = [];\n\n      for (let i = 0; i < fallingShape[0].length; i++) {\n        const row = [];\n        shape.push(row);\n        for (let u = (fallingShape.length - 1); u >= 0; u--) {\n          row.push(fallingShape[u][i]);\n        }\n      }\n\n      const collided = detectCollision(undefined, shape);\n\n      if (!collided) {\n        setFallingShape(shape);\n        console.log('rotate');\n        updateField(undefined, shape);\n      }\n\n    }\n\n    function dropNewShape() {\n      setFieldState(cloneMatrix(fieldWithShape));\n      setFallingShape(createRandomShape(getRandomColor()));\n      setShapePosition({x: FIELD_CENTER_X, y: 0});\n    }\n\n    function speedDropShape() {\n      setDirection('down');\n    }\n\n    function handleKeyUp(event) {\n      const time = new Date().getTime();\n      if (time - keyPressTime < 500) return;\n      keyPressTime.current = time;\n      if (event.key === 'ArrowRight') {\n        setDirection('right');\n      } else if (event.key === 'ArrowLeft') {\n        setDirection('left');\n      } else if (event.key === 'ArrowDown') {\n        setDirection('down');\n      } else if (event.key === 'ArrowUp')\n        rotateShape();\n    }\n\n    function handleKeyDown(event) {\n      if (event.keyCode === 32) {\n        speedDropShape();\n      }\n    }\n\n    function checkForFilledLine() {\n      const filledLines = [];\n      for (let i = 0; i < fieldWithShape.length - 1; i++) {\n        if (fieldWithShape[i].every((tile) => tile !== '0')) {\n          filledLines.push(i);\n        }\n      }\n      return filledLines;\n    }\n\n    function clearLine(lineIndexes) {\n      if (!lineIndexes.length) return;\n      const field = [];\n      lineIndexes.forEach(() => field.push([...initialFieldState[0]]));\n      for (let i = 0; i < fieldWithShape.length; i++) {\n        if (lineIndexes.every(index => index !== i)) {\n          field.push(fieldWithShape[i]);\n        }\n      }\n      setFieldState(field);\n    }\n    \n    if (direction) {\n      const newPos = moveShape(direction);\n      const isCollided = detectCollision(newPos);\n      setDirection(null);\n\n      if ((isCollided && direction === 'down') || shapePosition.y >= BOTTOM_WALL_Y - fallingShape.length) {\n        dropNewShape();\n        const filledRows = checkForFilledLine();\n        if (filledRows.length) clearLine(filledRows);\n      }\n      \n      if (!isCollided && (shapePosition.x !== newPos.x || shapePosition.y !== newPos.y)){\n        updateField(newPos);\n      }\n\n    }\n\n    document.addEventListener('keyup', handleKeyUp);\n\n    document.addEventListener('keydown', handleKeyDown);\n    \n    return () => {\n      document.removeEventListener('keyup', handleKeyUp);\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [shapePosition, direction, fallingShape, fieldState, fieldWithShape, initialFieldState]);\n\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setDirection('down');\n    }, 1000);\n    return () => clearInterval(interval);\n  });\n  \n  return (\n    <div className=\"Game\">\n      <Field state={fieldWithShape} />\n    </div>\n  );\n}\n\nexport default Game;\n","G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Field\\Field.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Space\\Space.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Brick\\Brick.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\components\\BlockFactory\\BlockFactory.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\components\\Tile\\Tile.js",[],"G:\\Учеба\\study\\frontend\\tetris\\src\\helpers\\index.js",[],{"ruleId":"43","replacedBy":"44"},{"ruleId":"45","replacedBy":"46"},{"ruleId":"47","severity":1,"message":"48","line":12,"column":9,"nodeType":"49","endLine":34,"endColumn":4},"no-native-reassign",["50"],"no-negated-in-lhs",["51"],"react-hooks/exhaustive-deps","The 'initialFieldState' array makes the dependencies of useEffect Hook (at line 271) change on every render. To fix this, wrap the initialization of 'initialFieldState' in its own useMemo() Hook.","VariableDeclarator","no-global-assign","no-unsafe-negation"]